# -*- coding: utf-8 -*-
======================================================= 需求 ===========================================================
1. 扫描页面
概述： 从裸磁盘，文件系统，文件 中扫描出全部的数据库页面。
具体：
    1. 根据页面结构和页头特征值去匹配页面。
    2. 根据各种条件校验算法来验证过滤匹配到的页面。
    3. 统计和记录扫描到的页面的信息到sqlite数据库(db)中。
目标：扫除所有的页面，并且尽量少的垃圾。记录出尽量多的信息，但要尽量少的db数据量.

2. 拼接页面（物理）
概述; 通过物理对象关系，聚合页面为碎片。
具体：
    1. 物理连续(文件号相同，页面号连续，页面物理偏移8K连续。间隔<8页的也算为连续) 的页面聚合为碎片。
    2. 半页匹配。两个碎片的首尾半页能匹配，就可聚合2个1中的碎片。
    3. 文件号相同，页号连续，pfs符合。并且只有一份的，拼接起来。
目标： 拼接尽量提高精度，准确度。

3. 拼接碎片（逻辑）
概述： 通过页面中的逻辑对象信息，进一步聚合碎片。
具体：
    1. IAM 页面
    2. obj+记录的列信息。
    3. index，根据索引记录中的指针，去定位数据页，通过这个定位去匹配符合所有定位的碎片。
目标：增加区分度，增加关联性。

4. 校验文件
概述： 校验拼出的文件的完整度和准确度
具体：
    1. IAM 页面
    2. 解析，挂载
目标： 拼接出完整数据文件，可挂载使用。

========================================================= 算法 =========================================================

1. 扫描页面
概述： 从裸磁盘，文件系统，文件 中扫描出全部的数据库页面。
目标：扫除所有的页面，并且尽量少的垃圾。记录出尽量多的信息，但要尽量少的db数据量.

    1.页面大小8K,扫描磁盘的步长为512B（可变）。
    2.匹配页面通过页头特征值校验，要尽可能的详细准确，但不要造成遗漏。具体算法在文档中。
    3.通过checksum校验和残缺页校验，或 无校验页的页尾行偏移 来过滤符合2的页面。
    4.扫到的页面，要记录页面的相关信息。包括 物理偏移 offset, 页号 page_no,文件号 file_no,页面类型 page_type
    把这些信息记录到sqlite库中。  mssql_page(dev_id,offset,page_no,file_no,page_type,obj_id)
    此库要尽量少的列，因为记录行数会很多。行很多时要分库。
设备表： devices(dev_id int,dev_type int,path text,start_pos int,size int,info text)
设别类型说明表： dev_type(dev_type int,dev_name )

2. 拼接页面（物理）
概述; 通过物理对象关系，聚合页面为碎片。 对1中的数据库操作。

    1. 物理连续(文件号相同，页面号连续，页面物理偏移8K连续。页号间隔<8页的也算为连续) 的页面聚合为碎片。
    2. 半页匹配。两个碎片的首尾半页能匹配，就可聚合2个1中的碎片。
    先按碎片的起始页号排序，再扫描所有1产生的碎片的尾部(页号n)后的页面，如果是半页，去后边的碎片(起始页号是n+2)头部匹配后半页。
    如果匹配上，两个碎片就聚合。记录断点。 碎片起始页号大于 n+2 就跳出循环。
    3. 文件号相同，页号连续，pfs符合。并且只有一份的，拼接起来。
    对于2中聚合好的碎片，去找能匹配到文件号相同，页号连续的碎片。如果没有，就不聚合。
    如果有，就用PFS，GAM去校验，如果只有一个匹配，就聚合，如果有多个匹配，就不聚合。
    （pfs中的百分比不准确，不可用）
    4. 聚合信息都记录在表里。有聚合中间表，聚合结果表。

3. 拼接碎片（逻辑）
概述： 通过页面中的逻辑对象信息，进一步聚合碎片。
    1. IAM 页面
    2. index
    3. obj+记录的列信息

IAM 页面
    通过PFS 取出所有有效的IAM页面（聚合为IAM页链）。
    聚合IAM链（可以作为拼接条件）时，做严格验证。包括，文件号相同，页号成链，obj_id相同。
    通过IAM页拼接， 匹配所有IAM的碎片进行拼接。 每次可以拼接多个碎片。

    IAM管理的页的 obj_id和subobj_id 相同。 与版本有关。
    2000的 只用obj_id， SQL2005/2008 的用obj_id和subobj_id，SQL2000升SQL2005/2008的只用obj_id

obj+记录的列信息。
    拼接碎片时，相同obj_id的页要 列信息相同。不同的踢掉。(对于有表结构变化的不可用，原因：当表结构变化时，同obj_id的数据页的列信息不同。)
    结合IAM页使用， 在IAM页匹配时，加入这个检测。

通过index页，去匹配碎片拼接
    扫描所有的索引页，猜解索引结构。然后根据索引记录中的指针，去定位数据页，通过这个定位去匹配符合所有定位的碎片。


======================================================================================================
解析 碎片中的记录
1. 29/22 或 sql 或 ini --> 列信息  <--匹配--> 碎片中的 obj_id + 列信息
2. 22/29/05/07 --> obj_id   <--匹配--> 碎片中的 obj_id


=============================================================================================================
复杂环境的恢复：
1. 信息获取
    1.从客户获取相关信息。
    2.从磁盘，自己搜集环境信息。
        1. 从文件系统
        2. 从数据库文件碎片获取
            扫描出所有的数据库文件(备份文件)头部，获取其中信息。
            master数据库中有系统信息
            bak文件头部中可以获得数据库信息，服务器信息

2.方案制定



